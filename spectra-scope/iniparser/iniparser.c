/*Copyright (c) <2013>, <Tian Lin Tan>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditionsare met:

1.	Redistributions of source code must retain the above copyright notice,
	this list of conditions and the following disclaimer.
2.	Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
*/
#include "iniparser.h"
#include "tokenizer.h"
#include "hashsetv.h"
#include "stringop.h"
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

/*
here are all the possible commands.
*/
enum command_name{
	SET_SECTION,
	INSERT_PAIR
};

/*
Command objects are consumed by the ini reader to build an in-memory
version of the file.
*/
struct command{
	enum command_name type;
	char * arg1;
	char * arg2;
};
static struct command * command_new(void)
{
	return calloc(1, sizeof(struct command));
}
static void command_del(struct command * com)
{
	if(com != NULL)
	{
		com->arg1 = NULL;
		com->arg2 = NULL;
		free(com);
	}
}

/*
The command stream object is used to produce a stream of commands.
It consumes tokens generated by a token stream.
*/
struct command_stream{
	struct token_stream * ts;
	int next_state;
	int end;
};

/*
Creates a new command stream from an open file stream with read permission.
*/
static struct command_stream * command_stream_new(FILE * fid)
{
	struct token_stream * ts = token_stream_new(fid);
	struct command_stream * cs = calloc(1, sizeof * cs);
	if(ts != NULL && cs != NULL)
	{
		cs->ts = ts;
		cs->next_state = 0;
		cs->end = 0;
	}
	else
	{
		free(cs);
		cs = NULL;
		token_stream_del(ts);
	}
	return cs;
}
static void command_stream_del(struct command_stream * cs)
{
	if(cs != NULL)
	{
		token_stream_del(cs->ts);
		free(cs);
	}
}
/*
This function is the core of the command stream.
It consumes a stream of tokens, and produces a stream of commands.
*/
static struct command * next_command(struct command_stream * cs)
{
	enum states{
		READ_NEXT,
		SCAN,
		BUILD_SET_SECTION,
		BUILD_INSERT_PAIR,
		BUILD_END,
		ERROR,
		SKIP_LINE,
	} state = cs->next_state;
	
	struct token_stream * ts = cs->ts;
	struct token tok;
	struct command * com = NULL;
	
	do switch(state){
	case READ_NEXT:// get the next token from the stream
		tok = token_stream_read(ts);
		state = SCAN;
	case SCAN://inspect the token, and decide what actions to take
		if(tok.type == TOKEN_TYPE_END)
			state = BUILD_END;
		else if(tok.type == TOKEN_TYPE_SECTION)
			state = BUILD_SET_SECTION;
		else if(tok.type == TOKEN_TYPE_NAME)
			state = BUILD_INSERT_PAIR;
		else if(tok.type == TOKEN_TYPE_NEWLINE)
			state = READ_NEXT;
		else
			state = SKIP_LINE;
		break;
	case BUILD_SET_SECTION:
		com = command_new();
		com->type = SET_SECTION;
		com->arg1 = tok.text;

		tok = token_stream_read(ts);
		assert(tok.type != TOKEN_TYPE_END);
		if(tok.type == TOKEN_TYPE_NEWLINE)
		{
			cs->next_state = READ_NEXT;
			return com;
		}
		else
			state = ERROR;
		break;
	case BUILD_INSERT_PAIR:
		com = command_new();
		com->type = INSERT_PAIR;
		com->arg1 = tok.text;

		tok = token_stream_read(ts);
		assert(tok.type != TOKEN_TYPE_END);
		if(tok.type == TOKEN_TYPE_ASSIGNMENT)
		{
		}
		else
		{
			state = ERROR;
			break;
		}

		tok = token_stream_read(ts);
		assert(tok.type != TOKEN_TYPE_END);
		if(tok.type == TOKEN_TYPE_NAME || tok.type == TOKEN_TYPE_STRING)
		{
			com->arg2 = tok.text;
		}
		else
		{
			state = ERROR;
			break;
		}

		tok = token_stream_read(ts);
		assert(tok.type != TOKEN_TYPE_END);
		if(tok.type == TOKEN_TYPE_NEWLINE)
		{
			cs->next_state = READ_NEXT;
			return com;
		}
		else
		{
			state = ERROR;
		}
		break;
	case BUILD_END:
		cs->end = 1;
		cs->next_state = BUILD_END;
		return NULL;
	case ERROR:
		if(com != NULL)
		{
			free(com->arg1);
			free(com->arg2);
			command_del(com);
			com = NULL;
		}
		state = SKIP_LINE;
	case SKIP_LINE:
		if(tok.type == TOKEN_TYPE_NEWLINE)
			state = READ_NEXT;
		else
			tok = token_stream_read(ts);
		break;
	}while(1);
}

/*
A structure to represent a key and value pair.
For ini file, value can either be a section table or a string.
This structure will be stored in hash sets to emulate hash tables.
Think of it as a tuple in a relational database table.
*/
struct entry{
	char * name;
	void * val;
};

/*
The name field is used to identify a pair.
Think of name as a primary key in a relational databse table.
*/
static int entry_cmp(void const * a, void const * b)
{
	struct entry const * e1 = a;
	struct entry const * e2 = b;
	return strcmp(e1->name, e2->name);
}
/*
This is a simple hash function for the hash sets.
*/
static unsigned entry_hash(void const * a)
{
	unsigned sum = 0;
	char const * s = ((struct entry *)a)->name;
	while(*s)
		sum = (sum * 257) + *s++;
	return sum;
}

/*
A structure to represent an ini object.
*/
struct ini{
	struct hashset * symtable;
};

/*
Create an empty ini object.
*/
struct ini * ini_new(void)
{
	struct ini * ini = calloc(1, sizeof *ini);
	struct hashset * hs =
		hashset_new(sizeof(struct entry), &entry_cmp, &entry_hash);
	if(ini != NULL && hs != NULL)
	{
		ini->symtable = hs;
	}
	else
	{
		free(ini);
		ini = NULL;
		hashset_del(hs);
	}
	return ini;
}
/*
Frees all memory used by this ini object.
The algorithm is described by the following pseudo code:
for each section s in ini
	for each pair p in section s
		free p
	free s
free ini
*/
void ini_del(struct ini * ini)
{
	if(ini != NULL)
	{
		struct hashset_iter * section_iter = hashset_iter_new(ini->symtable);
		while(hashset_iter_next(section_iter))
		{
			struct entry const * section = hashset_iter_get(section_iter);
			struct hashset * section_table = section->val;
			struct hashset_iter * val_iter = hashset_iter_new(section_table);
			
			while(hashset_iter_next(val_iter))
			{
				struct entry const * pair = hashset_iter_get(val_iter);
				free(pair->name);
				free(pair->val);
			}
			hashset_iter_del(val_iter);
			hashset_del(section->val);
			free(section->name);
		}
		hashset_iter_del(section_iter);
		hashset_del(ini->symtable);
		free(ini);
	}
}

/*
reads in a stream of commands, and insert pairs or create tables depending
on the command.
*/
int ini_read(struct ini * ini, FILE * fid)
{
	if(ini == NULL || fid == NULL)
		return -1;
	struct hashset * section_table = NULL;
	struct command_stream * cs = command_stream_new(fid);
	if(cs == NULL)
		return -1;
	
	// no section implies empty section [], so make a section for [] first
	struct command * com = command_new();
	com->type = SET_SECTION;
	com->arg1 = calloc(1, 1);
	
	while(com != NULL)
	{
		if(com->type == SET_SECTION)
		{
			struct entry * section = hashset_get(ini->symtable, &(struct entry){.name = com->arg1});
			//if section isn't already in, make a new one and insert it
			if(section == NULL)
			{
				char * section_name = cstr_dup(com->arg1);
				section_table = hashset_new(sizeof(struct entry), &entry_cmp, &entry_hash);
				hashset_insert(ini->symtable, &(struct entry){
					.name = section_name,
					.val = section_table
				});
			}
			//else point current section to the existing section
			else
			{
				section_table = section->val;
			}
			free(com->arg1);
		}
		else if(com->type == INSERT_PAIR)
		{
			struct entry * pair = hashset_get(section_table, &(struct entry){.name = com->arg1});
			//if pair is already in section, modify pair
			if(pair != NULL)
			{
				free(pair->val);
				pair->val = cstr_dup(com->arg2);
			}
			// if pair is not in, insert the new pair
			else
			{
				hashset_insert(section_table, &(struct entry){
					.name = cstr_dup(com->arg1),
					.val = cstr_dup(com->arg2)
				});
			}
			free(com->arg1);
			free(com->arg2);
		}
		command_del(com);
		com = NULL;
		com = next_command(cs);
	}
	command_stream_del(cs);
	return 0;
}
void ini_write(struct ini * ini, FILE * fid)
{
	struct hashset_iter * section_iter = hashset_iter_new(ini->symtable);
	while(hashset_iter_next(section_iter))
	{
		struct entry const * section = hashset_iter_get(section_iter);
		fprintf(fid, "[%s]\n", section->name);
		
		struct hashset * section_table = section->val;
		struct hashset_iter * val_iter = hashset_iter_new(section_table);
		while(hashset_iter_next(val_iter))
		{
			struct entry const * pair = hashset_iter_get(val_iter);
			fprintf(fid, "%s=\"", pair->name);
            
            // this loop inserts escapes if the string contains the character "
            char const * val = pair->val;
            for(unsigned i = 0, end = strlen(val); i < end; i++)
            {
                if(val[i] == '"')
                    fputc('\\', fid);
                fputc(val[i], fid);
            }
            fprintf(fid, "\"\n");
		}
		hashset_iter_del(val_iter);
	}
	hashset_iter_del(section_iter);
}

char const * ini_get(struct ini const * ini, char const * section_name, char const * key_name)
{
	struct entry * section = hashset_get(ini->symtable, &(struct entry){.name = (char*)section_name});
	if(section != NULL)
	{
		struct hashset * section_table = section->val;
		struct entry * pair = hashset_get(section_table, &(struct entry){.name = (char*)key_name});
		if(pair != NULL)
			return pair->val;
		else
			return NULL;
	}
	else
		return NULL;
}
int ini_set(struct ini * ini, char const * section_name, char const * key, char const * val)
{
	
	struct hashset * section_table = NULL;
	// first find the section
	{
		struct entry * section = hashset_get(ini->symtable, &(struct entry){.name = (char*)section_name});
		if(section != NULL)
			section_table = section->val;
	}
	
	// create section if it doesn't exist
	if(section_table == NULL)
	{
		section_table = hashset_new(sizeof(struct entry), &entry_cmp, &entry_hash);
		hashset_insert(ini->symtable, &(struct entry){
			.name = cstr_dup(section_name),
			.val = section_table
		});
	}
	
	// then find key value pair in section
	struct entry * pair = hashset_get(section_table, &(struct entry){.name = (char*)key});
	
	// insert key value pair if pair doesn't exist
	if(pair == NULL)
	{
		hashset_insert(section_table, &(struct entry){
			.name = cstr_dup(key),
			.val = cstr_dup(val)
		});
	}
	// otherwise set value
	else
	{
		free(pair->val);
		pair->val = cstr_dup(val);
	}
	return 0;
}
